---
title: 'Seurat processing'
author: "Jon Thompson, Pascal N. Timshel, Pers lab"
date: "`r Sys.time()`" 
output:
  html_notebook: 
    df_print: paged
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
  html_document:
    df_print: paged
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
---
  
# Setup

## Load libraries

```{r}

suppressPackageStartupMessages(library(Seurat))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(Matrix))
#suppressPackageStartupMessages(library(tidyr))
#suppressPackageStartupMessages(library(flashClust))
#suppressPackageStartupMessages(library(xlsx))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(dplyr))
#suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(parallel))

```

## Set constants

```{r}
#dir.arclira_src <- "/projects/timshel/sc-arc_lira/src"
#dir.pers_lab_sc_lib <- "/projects/timshel/git/perslab-sc-library"
#dir.seurat.sc <- "/projects/jonatan/seurat-src"
source(sprintf("%s/constants-sample_meta_data.R", dir.arclira_src)) # loads sample meta-data
#source(sprintf("%s/constants-gene_markers_data.R", dir.arclira_src)) # loads gene markers
#source(sprintf("%s/constants-cell_type_annotations.R", dir.arclira_src)) # loads cell type annotations
source(sprintf("%s/seurat_functions/load_functions.R", dir.pers_lab_sc_lib)) # load Pers lab/Timshel single-cell library
#source(sprintf("%s/seurat_functions/plot_dotplot_celltype_highlight.R", dir.pers_lab_sc_lib)) # DotPlot_Timshell function
#df.markers.perslab
#source(file = "/projects/jonatan/functions-src/params_functions.R") # Jonatan scripts

dir.project = "/projects/jonatan/tmp-holst-hsl/" # needs to have '/Robjects' and '/tables' subdirectories
dir.plots = paste0(dir.project,"plots/")
dir.tables = paste0(dir.project,"tables/")

flag.sc = "campbell"
output.prefix <- "seurat"
flag.date = substr(gsub("-","",as.character(Sys.Date())),3,1000)

path.data = "/data/pub-perslab/campbell-nn-2017/geo/GSE93374_Merged_all_020816_DGE.txt.gz"
path.metadata = "/data/pub-perslab/campbell-nn-2017/geo/GSE93374_cell_metadata.txt.gz"
res.primary <- 0.8 # the primary resolution - will be used for cluster marker identification.
res2calculate <- c(0.4, 0.6, 0.8, 1.2, 1.6, 2, 4, 10) # Alternative resolutions to calculate for FindClusters. OBS: res.primary must be included in res2calculate

N_PC <- 120 # number of Principal Components to use in RunPCA
N_CORES_MAX <- 10 # max number of cores to use for parallel computing
```

## Load sequence data and create Seurat Object

```{r}
# load data
raw_data <- read.csv(gzfile(path.data), sep="\t")

# intialize Seurat object
# keep all genes expressed in => 3 cells and all cells with at least 200 detected genes
seurat_obj <- CreateSeuratObject(raw.data = raw_data, 
                                 min.cells = 3, 
                                 min.genes = 200, 
                                 project = sprintf("%s_%s", flag.sc, output.prefix))

```

## Add meta data

```{r}

metaData <- data.frame(read.delim(path.metadata))
rownames(metaData) <- metaData$X1.ID

all.equal(row.names(metaData),row.names(seurat_obj@meta.data))

seurat_obj <- AddMetaData(seurat_obj, metaData)

# Check that the levels of the metadata are preserved
lengths_meta_orig <- sapply(metaData,function(x) length(levels(x)))[-1]
lengths_meta_obj <- sapply(seurat_obj@meta.data,function(x) length(levels(x)))[5:18]
all.equal(lengths_meta_orig,lengths_meta_obj)

```

# Quality Control 

## Do QC and select genes for further analysis

Find mito + ribo gene percentages and nUMI and nGene and append to cells as meta data
```{r}
# see https://davetang.org/muse/2017/08/01/getting-started-seurat/
#

mito.genes <- grep(pattern = "^mt-", x = rownames(x = seurat_obj@data), value = TRUE, ignore.case=T)
ribo.genes <- grep(pattern = "^Rp[sl][[:digit:]]", x = rownames(x = seurat_obj@data), value = TRUE)
percent.mito <- Matrix::colSums(seurat_obj@raw.data[mito.genes, ])/Matrix::colSums(seurat_obj@raw.data)
percent.ribo <- Matrix::colSums(seurat_obj@raw.data[ribo.genes, ])/Matrix::colSums(seurat_obj@raw.data)
seurat_obj <- AddMetaData(object = seurat_obj, metadata = percent.mito, col.name = "percent.mito")
seurat_obj <- AddMetaData(object = seurat_obj, metadata = percent.ribo, col.name = "percent.ribo")

dim(seurat_obj@meta.data)
```

## Plot cells on QC variables 

GenePlot is typically used to visualize gene-gene relationships, but can
be used for anything calculated by the object, i.e. columns in
object@meta.data, PC scores etc. 

Use the plot to check if a subset of cells
have an outlier level of high mitochondrial percentage and also low UMI
content, to decide whether or not to filter them out.

```{r, fig.height=10, fig.width=10}

VlnPlot(object = seurat_obj, features.plot = c("nGene", "nUMI", "percent.mito","percent.ribo"), nCol = 4)
par(mfrow = c(1, 2))

GenePlot(object = seurat_obj, gene1 = "nUMI", gene2 = "percent.mito")
GenePlot(object = seurat_obj, gene1 = "nUMI", gene2 = "percent.ribo")
GenePlot(object = seurat_obj, gene1 = "percent.mito", gene2 = "percent.ribo")
GenePlot(object = seurat_obj, gene1 = "nUMI", gene2 = "nGene")
```

## Filter out cells whose gene reads are outside an appropriate range 
NB: inspect plots before setting values
```{r}

# Keep: 100 < unique gene counts < 5000, -Inf < percent mito and ribo < 0.25
seurat_obj <- FilterCells(object = seurat_obj, subset.names = c("nGene", "percent.mito", "percent.ribo"), low.thresholds = c(200, -Inf, -Inf), high.thresholds = c(5000,0.05,0.05)) 

```

# Normalizing and scaling

## Normalize the data
For each cell, divide gene read counts by the total within the cell, multiply by 10e4 and take the log.

```{r}
seurat_obj <- NormalizeData(object = seurat_obj, normalization.method = "LogNormalize",  scale.factor = 1e4, display.progress=T)
# Normalised data is stored in seurat_obj@data

```

## Scale the data and regress out confounders 

From http://satijalab.org/seurat/pbmc3k_tutorial.html:
Seurat can regress out cell-cell variation in gene expression driven by batch (if applicable), cell alignment rate (as provided by Drop-seq tools for Drop-seq data), the number of detected molecules, and mitochondrial gene expression. For cycling cells, we can also learn a ‘cell-cycle’ score and regress this out as well. 

nUMI captures the phenomenon that certain genes may be more sensitive to sequencing depth than others, so we build a linear model from nUMI -> gene expression scaling.

```{r}
seurat_obj <- ScaleData(object = seurat_obj, genes.use = NULL, vars.to.regress = c("nUMI", "percent.mito", "percent.ribo"), model.use="linear", do.scale=T, do.center=T, do.par=T, num.cores=5) # NULL->default: genes.use = all genes in @data
```

## Find variable genes  

From http://satijalab.org/seurat/pbmc3k_tutorial.html:
Seurat calculates highly variable genes and focuses on these for downstream analysis. FindVariableGenes calculates the average expression and dispersion for each gene, places these genes into bins, and then calculates a z-score for dispersion within each bin. This helps control for the relationship between variability and average expression. 
We suggest that users set these parameters to mark visual outliers on the dispersion plot, but the exact parameter settings may vary based on the data type, heterogeneity in the sample, and normalization strategy. The parameters represent typical parameter settings for UMI data that is normalized to a total of 1e4 molecules.

```{r}
# NB: Seurat finds variable genes using seurat_obj@data rather than seurat_obj@scaled.data. It's not clear why, since the ScaleData function by default works on @data rather than the variable genes subset. May try to store scaled data in @data slot, then find variable genes.

seurat_obj <- FindVariableGenes(object = seurat_obj, mean.function = ExpMean, dispersion.function = LogVMR, 
                          x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5, do.plot=F)

length(seurat_obj_centerF@var.genes) # Check how many genes are variable

```

## Run PCA 

```{r}
seurat_obj <- RunPCA(object = seurat_obj, pc.genes = seurat_obj@var.genes, pcs.compute=N_PC, do.print = F)#, pcs.print = 1:5, genes.print = 5)

# Draw elbow plot of PCs to identify a good cut-off for downstream analysis 
PCElbowPlot(object = seurat_obj, num.pc=N_PC)
```

## Set number of PCs to use for clustering. More rigourous methods exist - see http://satijalab.org/seurat/pbmc3k_tutorial.html

```{r}
nPC_seurat = 40
```

## Cluster cells with different resolution parameter

From http://satijalab.org/seurat/pbmc3k_tutorial.html:

The FindClusters function's resolution parameter sets the ‘granularity’ of the downstream clustering, with increased values leading to a greater number of clusters. We find that setting this parameter between 0.6-1.2 typically returns good results for single cell datasets of around 3K cells. **Optimal resolution often increases for larger datasets**. The clusters are saved in the object@ident slot.

```{r}
# Set up a cluster of processor cores for parallel computation

cl <- makeCluster(min(length(res2calculate),N_CORES_MAX), type = "FORK")

# Check the libraries are installed on all cores in cluster 
suppressMessages(clusterEvalQ(cl, library(Seurat)))
suppressMessages(clusterEvalQ(cl, library(tidyverse)))
suppressMessages(clusterEvalQ(cl, library(rlang))) # needed for using UQ()

# Run FindClusters in parallel using different resolution parameter values
list_seurat_objs <- parLapply(cl, res2calculate, function(x) FindClusters(object = seurat_obj, reduction.type = "pca", dims.use = 1:nPC_seurat, print.output = 0, save.SNN = T, resolution = x))

stopCluster(cl)

# Save all the cluster assignments as meta data in the original seurat object
for (i in seq(1:length(res2calculate))) {
  seurat_obj <- AddMetaData(seurat_obj, list_seurat_objs[[i]]@ident, col.name = paste0("clust.res.", res2calculate[i]))
}

rm(list_seurat_objs) # No need to have this massive list in session!
```

```{r}
# OR: run for loop over the different resolution parameter values

# for (tmp.res in res2calculate) {
#   seurat_obj <- FindClusters(object = seurat_obj, reduction.type = "pca", dims.use = 1:nPC_seurat, print.output = 0, save.SNN = T, force.recalc=F, resolution = tmp.res)
# } # Seurat stores the most recent cluster identities in seurat_obj@ident and the previous ones in @meta.data 
```

```{r}
# Commented out because we compute differential cluster marker genes for each clustering allocation below
# seurat_obj <- SetAllIdent(seurat_obj, id=paste0("res.", res.primary)) # *IMPORTANT* set ident to the primary ident. This is needed for correct use of cluster marker gene identification
```

## Do TSNE

From http://satijalab.org/seurat/pbmc3k_tutorial.html:
tSNE aims to place cells with similar local neighborhoods in high-dimensional space together in low-dimensional space. 
As input to the tSNE, we suggest using the same PCs as input to the clustering analysis, although computing the tSNE based on scaled gene expression is also supported using the genes.use argument.

```{r}
# Compute the TSNE projections
seurat_obj <- RunTSNE(object = seurat_obj, reduction.use = "pca", dims.use = 1:nPC_seurat, do.fast = TRUE)
```

## Find differentially expressed genes (cluster biomarkers)

```{r, echo=F}

list.df.cluster_markers = list(length(res2calculate))

for (i in seq(length(res2calculate))) {
  
  seurat_obj <- SetAllIdent(seurat_obj, id=paste0("res.",res2calculate[i])) # set cell identity for clustering
  
  # Get a list of cluster IDs
  cluster_ids <- sort(unique(as.numeric(seurat_obj@meta.data[,paste0("res.",res2calculate[i])]))) 
  # numeric vector, 0, 1, 2, 3, ...   (N_CLUSTERS-1)  
  
  # Set up a cluster of processor cores for parallel computation
  cl <- makeCluster(min(length(cluster_ids),N_CORES_MAX), type = "FORK")
  
  # Check the libraries are installed on all cores in cluster 
  clusterEvalQ(cl, library(Seurat))
  clusterEvalQ(cl, library(tidyverse))
  clusterEvalQ(cl, library(rlang)) # needed for using UQ()
  
  # Run FindMarkers in parallel on the cell clusters
  list_of_dfs.all_markers <- parLapply(cl, cluster_ids, function(x) FindMarkers(object = seurat_obj, ident.1 = x, min.pct = 0.25, only.pos = TRUE, thresh.use = 0.25))
  
  stopCluster(cl)
  
  list_of_dfs.all_markers_names <- lapply(list_of_dfs.all_markers, function(x) cbind(x,gene=rownames(x), stringsAsFactors = F)) 
  # add gene name as column in each dataframe. stringsAsFactors avoids "Unequal factor levels" warning from bind_rows().
  names(list_of_dfs.all_markers_names) <- cluster_ids # set names so bind_rows will get the .id correct
  df.cluster_markers <- bind_rows(list_of_dfs.all_markers_names,.id="cluster") # combine list of dfs into one data frame
  df.cluster_markers %>% group_by(cluster) %>% top_n(100, avg_logFC) # Display the top markers we computed above
  
  list.df.cluster_markers[[i]] <- df.cluster_markers
  }

```

```{r, echo=F}
save.image(file=sprintf("%s_%s_rsession.RData", flag.sc, output.prefix)) # save session image
```
